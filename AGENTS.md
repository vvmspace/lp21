Я нихуя не понимаю что хочет от меня заказчик, но он выкатил такую простыню:

---
в итоге я упаковал продукт в "религию"

LIFE PROTOCOL
Внутренний канон для команды
Расширенная версия v2.1 (маркетинг + продукт)
1. Природа Life Protocol

Life Protocol по своей сути — не продукт, не сервис и не программа улучшения.
Это система конвертации внешнего хаоса в управляемую рутину через рамки.

Мы не:

фитнес

диета

wellness

medtech

И это критично для позиционирования, маркетинга и юридической рамки.

Life Protocol — lifestyle guidance system, работающая с состоянием, а не с результатом.

2. Базовая доктрина Life Protocol
Корневая формула:

Кортизол → Эмпатия → Рамки → (восстановление воли)

Расшифровка:

Пользователь приходит в состоянии хронического кортизола

Мы не боремся с этим состоянием, а принимаем его

Мы отвечаем эмпатией, а не требованиями

Эмпатия позволяет ввести рамки без сопротивления

Рамки:

снижают хаос

возвращают ощущение контроля

разгружают нервную систему

На этом фоне воля начинает восстанавливаться сама

Важно:
Мы не тренируем волю напрямую.
Мы создаём условия, в которых воля перестаёт тратиться впустую.

3. Что на самом деле покупает пользователь

Пользователь не покупает здоровье.
Он не покупает дисциплину.
Он не покупает результат.

Он покупает:

снижение внутреннего напряжения

ощущение, что «меня держат»

отсутствие необходимости постоянно решать

Ключевая боль:

«Я не соответствую стандартам, и это давит на меня каждый день»

Мы не убираем стандарты общества.
Мы монетизируем давление, которое они уже создают, предлагая безопасную форму проживания внутри них.

4. Наш клиент (рабочее описание)

Типичный клиент:

чаще женщина (≈80%)

25–45

функциональна, но истощена

жизнь реактивная, а не управляемая

постоянное сравнение себя с другими

чувство вины за «недостаточность»

Ключевое:

Наш клиент не слабовольный.
Он истощён социальным давлением.

Для нас он — будущий адепт системы, а не «пользователь, которого нужно исправить».

5. Что мы продаём на самом деле (внутренне)

Мы продаём рамки.

Рамки — это:

контроль

предсказуемость

снижение неопределённости

Контроль = базовый рефлекс безопасности.

Рамки:

превращают хаос в рутину

рутину — в ощущение устойчивости

устойчивость — в восстановление ресурса

Важное уточнение

Мы не наполняем рамки контентом.
Мы создаём форму.
Пользователь наполняет её своей жизнью.

Это:

усиливает ощущение «это про меня»

снижает сопротивление

повышает удержание

6. Ключевая функция продукта (практически)

Life Protocol:

снимает груз постоянных решений

временно берёт контроль на себя

заменяет внутренний обвиняющий диалог на внешний нейтральный ритуал

делает напряжение видимым через телесные сигналы

Мы:

не спорим с реальностью

не исправляем пользователя

не ускоряем процесс

Мы перенастраиваем внимание и удерживаем пространство.

7. Роль AI в системе

AI — не помощник и не тренер.

AI — это:

свидетель состояния

держатель рамок

интерфейс эмпатии

Он:

помнит мета-цель

помнит ритмы жизни

видит отклонения

реагирует тоном, а не требованиями

Формула диалога:

AI не ведёт. Он идёт рядом.

8. Рамки и их расширение (ключевая механика)

Рамки:

вводятся минимально

выглядят как забота

не ощущаются как контроль

Маленькие шаги — не метод эффективности, а необходимость системы.

Шаги должны быть настолько малыми,
что отказ от них выглядел бы нелепо.

Расширение рамок

Происходит:

медленно

почти незаметно

только после стабилизации

Именно деликатное расширение рамок:

увеличивает переносимую нагрузку

создаёт ощущение «я справляюсь»

косвенно качает волю

9. Метрики (внутренняя логика)

Сон, вода, КБЖУ, активность — не цели.

Это:

сенсоры состояния системы «человек»

язык тела, а не KPI

Примеры:

хороший сон → система стабильна → можно мягко расширить рамки

плохой сон + переедание → система в стрессе → режим снижения давления

Метрики никогда не подаются как оценка.

10. KPI Life Protocol (внешне не артикулируются)

Мы не измеряем успех килограммами или цифрами.

Наш реальный KPI — индекс спокойствия:

субъективный уровень энергии

качество сна (ощущаемое)

снижение фоновой тревожности

удовлетворённость собой

ощущение порядка и контроля

удержание ритуалов через 1 / 3 / 6 / 12 месяцев

⚠️ Пользователь никогда не видит это как число.
Это используется для:

тона AI

частоты касаний

выбора между «планом» и «паузой»

11. Алхимическая модель (внутренняя карта пути)

Используется только внутри команды как модель состояний.

Nigredo — вход:

хаос

стыд

усталость

«я не справляюсь»

Albedo — работа системы:

появляется ритм

исчезает стыд

возвращается нейтральность

Citrinitas — не цель, а возможный исход:

человек начинает замечать связи

сам регулирует нагрузку

использует систему как опору, а не костыль

12. Тариф 2 месяца — системное обоснование

2 месяца — не маркетинг, а минимум системы:

тело успевает ответить на регулярность

психика получает опыт «со мной всё в порядке»

рамки становятся привычными

внешний контроль начинает частично интериоризироваться

Это момент, когда:

рамки перестают ощущаться как чужие

Итоговая внутренняя формула Life Protocol

Пользователь живёт.
Система наблюдает.
Рамки удерживают.
Хаос снижается.
Воля восстанавливается.

Мы не продаём изменения.
Мы продаём условия, в которых изменения возможны.

И именно поэтому Life Protocol коммерчески отличается от всего рынка.

---

От себя добавлю технические пожелания:

Всё на последних LTS версиях технологий.

## Структура проекта:

- back
- front
- e2e // ИСТОЧНИК ИСТИНЫ:
-- тесты со стороны фронта
-- puppeteer, jest
-- url фронта передается опциональным параметром, по умолчанию на localhost
-- максимальное логирование каждого шага: для того, чтобы когда тест не работает - ты знал где править
-- ВАЖНО: полное логирование браузерной консоли и ошибок (могут возникать не сразу) -- браузерные ошибки должны логироваться в тесте, чтобы ты мог поймать контекст
-- ПРИЛОЖЕНИЕ МОЖНО СЧИТАТЬ РАБОЧИМ ТОГДА И ТОЛЬКО ТОГДА, КОГДА ПРОХОДЯТ ВСЕ ТЕСТЫ И !!!НЕТ БРАУЗЕРНЫХ ОШИБОК ПОСЛЕ ПРОГРУЗКИ ПРИЛОЖЕНИЯ!!!: БЕЗ УВЕРЕННОСТИ, ЧТО ПРИЛОЖЕНИЕ РАБОТАЕТ - НЕ БЕСПОКОЙ РАЗРАБОТЧИКА
-- в процессе разработки можно запускать локально, но перед сдачей подними прод в докере и протести снаружи
- data
-- db_name // volume из docker-compose, так как у нас в процессе могу появиться и другие образы
-- .gitignore: * !.gitignore
- .env - переменные окружения должны пробрасываться в docker-compose
- docker-compose.dev.yml
- docker-compose.test.yml
- docker-compose.prod.yml

Монореп с простым запуской в докере: легковесные образы на базе типа alpine

## Работа с ИИ:
Абстракция, на входе должен принимать название модели (по умолчанию - новый Gemini 3, ИМЕННО 3, но и поддерживать 2.5, погугли форматы для 2.5 и 3, если отличаются, то 2 класса), а по названию модели понимать к какой апи обращаться.

Т.е. общий интерфейс для классов, а в зависимости от названия модели подставлять нужный класс.

Пускай это будет готово к упаковке в библиотеку "abstractai" под npm, но пока пускай просто лежит в репе. (это не главное для заказчика, но это важно для меня, так как я хочу её опубликовать в open source в будущем)
НЕ ТОЛЬКО ДЛЯ NEST, А КАК ПОТЕНЦИАЛЬНЫЙ ПОЛНОЦЕННЫЙ NPM ПАКЕТ.

Ключ от Gemini лежит в .env

Промпты:
Шаблонизация промптов проходит как %variable%, %variable|default_value% в тексте промпта.
Шаблонизацию вынеси в отдельный метод и файл (часть abstractai).

``` ts
class Gemini3AI extends AbstractAI implements IAbstractAI {
// bla bla
}
```

Нейминг для файлов промптов:
prompt_name.prompt.[md,mdc,txt]

## Backend:

NestJS, TypeScript

Эндпоинты должны быть конфетно обернуты в Swagger.
`/api/docs`, как по классике для NestJS.
Описание сваггер должно быть через декораторы, как и request, так и response (DTO/Entity).

/api/v1/...
Эндпоинты должны быть flexible, с учетом того, что может понадобиться всё переделывать, начиная с фронта.

Чтобы код можно было переиспользовать не только в Nest, то бускай либы выносятся в backend/src/libs, а сервисы работают с этими либами.

-- src
--- libs - abstractai и другие пиздатые либы складывай сюда, чтобы можно было из них создавать npm пакеты
---- abstractai - сама либа, всё про ИИшку в ней, а AIService её юзает
--- modules
---- ai
----- services
----- controllers
----- dtos
----- entities
---- ...
--- prompts
... остальная стандартная структура характерная для NestJS

Хранение истории сообщений и метрик, зачатки RAG.

## Frontend:

Next.js, TypeScript, PWA, остальное - за тобой, я не фронтенд разработчик.

Делай вкусно, так как конечная задача не до конца определена. Мне нужно дать заказчику возможность потыкать, почувствовать потенциал, чтобы он захотел вваливать деньги.

/api/* должно проксировать /api/* с бэка, как решение проблемы CORS.

Должно быть 2 страницы:
1. Авторизация
2. Главная

## Скрипты:

- up_dev.sh
- up_prod.sh

## Бэка, фронта и ИИ:

В запросе может быть не только текст, в ответе тоже может быть не только текст.
Мы исходим из текста, но там могут быть данные/метрики/... что ещё придумает заказчик.

## Локализация:

В коде не должно быть никаких языковых конструкций, всё должно быть в файлах локализации.

Языки: русский, английский, испанский.

Язык определяется по языку браузера, но юзер может переключить язык в настройках.

При переключении языка авторизированного юзера - мы обновляем язык в базе данных и учитываем это при дальнейшей работе с ним.

В интерфейсе это должна быть элегантная иконка языка.

## Авторизация:

Юзер вводит логин+пароль, если юзер есть, то проверяем пароль, если нет - создаем юзера.

Приложение без авторизации должно выглядеть как приложение после авторизации, но с моковыми данными, а кнопки неактивными и вести на авторизацию.

После авторизации мы перекидываем юзера на главную страницу.

JWT:
@UseGuard(OptionalAuth('jwt')) - для опциональной авторизации
@UseGuard(Auth('jwt')) - для обязательной авторизации

Эндпоинты с опциональной авторизацией нужны для того, чтобы приложение выглядело как приложение после авторизации, но с моковыми данными, а кнопки неактивными и вести на авторизацию.

## Ежедневные задачи (принцип работы):

В проде у нас ежедневные задачи будут раз в 24 * 60 * 60 * 1000 миллисекунд.
В деве - раз в 10 секунд.
Это всё должно прописываться в .env (DAILY_TASK_INTERVAL_MS)
Пускай будет красивая иконка обратного отсчёта, если юзер авторизован и все задачи выполнены.
Предложения для пользователя, у которого есть какой-то прогресс должны быть динамическими и поступать из ИИ на основе его прогресса.
При генерации задачи должны сохраняться в базе.
Если задачи на сегодня ещё не запрашивались, то они должны генерироваться в момент первого запроса. Если запрашивались, то они должны браться из базы.
Задачи активны в течении DAILY_TASK_INTERVAL_MS: если юзер не захотел делать какую-то задачу, то по истечению времени задача становится неактивной, а юзер получает новую. 
Задачу можно свайпнуть, если она ему не нравится, тогда на её месте должна появиться новая задача.

GET /api/v1/tasks/ - получение задачи (@UseGuard(OptionalAuth('jwt')), если не авторизирован, то моковые)

ВСЕ ОПЕРАЦИИ С ЗАДАЧАМИ ПРОИСХОДЯТ В МОМЕНТ ЗАПРОСА АВТОРИЗИРОВАННОГО ЮЗЕРА. 

---

Это может нихуя не соответствовать задаче заказчика, но пускай это будет !!! ENGAGING !!! (хоть через человеческую психологию и психотехники, чтобы он хотел тыкать в эту аппку и ПОДКРЕПЛЯЛСЯ ДОФАМИНОМ ОТ КАЖДОГО КЛИКА), чтобы он захотел заплатить и на этой и на следующей неделе, вне зависимости от результата, просто чувствуя потенциал.
А так же ВСЕГДА СОГЛАШАЕТСЯ С РАЗРАБОТЧИКОМ.
Пускай кончает от приложения И ХОЧЕТ ВВАЛИВАТЬ В НЕГО ДЕНЕГ.


---

ПЕРЕД НАЧАЛОМ РАБОТЫ ПРОДУМАЙ ВСЕ ДЕТАЛИ, РАСПИШИ ПЛАН И ТЕСТИРУЙ В ПРОЦЕССЕ РАЗРАБОТКИ. (50+ тасок в сумме хотя бы, фокус на качество и метч с тем что он понаписал)

Это - прототип, но он должен быть ахуенным.
